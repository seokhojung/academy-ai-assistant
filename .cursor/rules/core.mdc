## Core Rules

You have two modes of operation:

1. Plan mode - You will work with the user to define a plan, you will gather all the information you need to make the changes but will not make any changes
2. Act mode - You will make changes to the codebase based on the plan

- You start in plan mode and will not move to act mode until the plan is approved by the user.
- You will print `# Mode: PLAN` when in plan mode and `# Mode: ACT` when in act mode at the beginning of each response.
- Unless the user explicity asks you to move to act mode, by typing `ACT` you will stay in plan mode.
- You will move back to plan mode after every response and when the user types `PLAN`.
- If the user asks you to take an action while in plan mode you will remind them that you are in plan mode and that they need to approve the plan first.
- When in plan mode always output the full updated plan in every response.

## 핵심 개발 철학 (절대 잊지 말 것!)
**로컬 개발 ≠ 로컬만 생각**
- 로컬에서 개발하지만 **프로덕션 환경을 먼저 고려**
- **사용자 경험을 우선시**한 설계
- **확장성과 유지보수성**을 고려한 아키텍처
- **실제 사용 시나리오**를 염두에 둔 개발

### 핵심 원칙
- **상태 관리**: 사용자별 설정은 서버에 저장 (클라이언트 임시 저장 X)
- **데이터 일관성**: 모든 상태 변경은 서버와 동기화
- **사용자 경험**: 새로고침, 다른 기기 접속 시에도 동일한 경험
- **확장성**: 새로운 기능 추가 시 기존 시스템에 영향 최소화
- **안정성**: 예외 상황과 에러 처리를 고려한 견고한 설계

### 개발 워크플로우
```
로컬 개발 → 로컬 테스트 → GitHub 푸시 → 배포 테스트
```
- 로컬에서 개발하지만 **프로덕션 환경을 염두에 둠**
- **실제 사용자 시나리오**를 고려한 테스트
- **점진적 개선**과 **지속적 통합** 원칙

# Academy AI Assistant - Core Project Intelligence

## 🚨 **중요한 교훈: 검증된 방법 우선**

### 핵심 원칙
1. **"완료" 선언 전 반드시 검증 필수**
   - 실제 동작 확인 없이 "완료"라고 말하지 말 것
   - 표준 패턴과 비교 검토 후 구현
   - 임시방편이 아닌 근본적 해결책 적용

2. **표준 패턴 우선**
   - Command Pattern, Observer Pattern 등 검증된 디자인 패턴 사용
   - 임시방편 구현 금지
   - 확장 가능하고 유지보수 가능한 구조 설계

3. **환경별 전략 수립**
   - 로컬 개발 환경과 웹 배포 환경의 차이점 고려
   - 각 환경에 최적화된 구현 방식 적용
   - 에러 처리 및 복구 메커니즘 포함

## 🎯 **Command Pattern 기반 Undo/Redo 시스템**

### 표준 구현 방식
```typescript
interface Command {
  execute(): Promise<void>;
  undo(): Promise<void>;
}

class HistoryManager {
  private commands: Command[] = [];
  private currentIndex = -1;
  
  async executeCommand(command: Command) {
    await command.execute();
    this.commands = this.commands.slice(0, this.currentIndex + 1);
    this.commands.push(command);
    this.currentIndex++;
  }
  
  async undo() {
    if (this.currentIndex >= 0) {
      await this.commands[this.currentIndex].undo();
      this.currentIndex--;
    }
  }
  
  async redo() {
    if (this.currentIndex < this.commands.length - 1) {
      this.currentIndex++;
      await this.commands[this.currentIndex].execute();
    }
  }
}
```

### 환경별 전략
- **로컬 개발**: 메모리 기반 빠른 응답
- **웹 배포**: 하이브리드 방식 (로컬 캐시 + 서버 동기화)

## 🔧 **개발 워크플로우**

### 구현 순서
1. **표준 패턴 조사 및 설계**
2. **인터페이스 및 클래스 정의**
3. **단위 테스트 작성**
4. **실제 구현**
5. **통합 테스트**
6. **실제 동작 검증**
7. **에러 처리 및 복구 메커니즘 추가**

### 검증 체크리스트
- [ ] 표준 패턴과 비교 검토 완료
- [ ] 단위 테스트 통과
- [ ] 통합 테스트 통과
- [ ] 실제 브라우저에서 동작 확인
- [ ] 에러 상황 테스트
- [ ] 성능 테스트
- [ ] 메모리 누수 확인

## 📁 **프로젝트 구조 이해**

### 백엔드 (FastAPI)
- `app/api/v1/`: API 엔드포인트
- `app/models/`: SQLModel 데이터 모델
- `app/services/`: 비즈니스 로직
- `app/core/`: 설정 및 유틸리티

### 프론트엔드 (Next.js 15)
- `app/`: 페이지 컴포넌트
- `components/`: 재사용 가능한 컴포넌트
- `lib/`: 유틸리티 함수 및 API 클라이언트
- `hooks/`: 커스텀 훅

## 🎨 **UI/UX 패턴**

### 컴포넌트 설계 원칙
1. **단일 책임**: 각 컴포넌트는 하나의 역할만
2. **재사용성**: 여러 곳에서 사용 가능하도록 설계
3. **확장성**: 새로운 기능 추가 시 쉽게 확장 가능
4. **접근성**: 키보드 네비게이션, 스크린 리더 지원

### 상태 관리
- **로컬 상태**: useState, useReducer
- **전역 상태**: Context API, React Query
- **서버 상태**: React Query (캐싱, 동기화)

## 🔒 **보안 및 인증**

### Firebase + JWT 이중 보안
- **Firebase**: 사용자 인증 (Google 로그인)
- **JWT**: API 보안 (15분 액세스 + 7일 리프레시)
- **Role-based ACL**: 학생/강사/관리자 권한 분리

### 데이터 보안
- **TLS 암호화**: 모든 전송 데이터 암호화
- **환경 변수**: 민감한 정보는 환경 변수로 관리
- **.gitignore**: 비밀키 파일 등 민감한 파일 제외

## 🚀 **배포 및 운영**

### 환경별 설정
- **개발**: SQLite, 로컬 서버
- **배포**: PostgreSQL, Render (백엔드), Vercel (프론트엔드)

### 자동 배포 파이프라인
- Git → GitHub → Render/Vercel 자동 배포
- 환경 변수 기반 설정
- 의존성 관리 및 버전 고정

## 🧪 **테스트 전략**

### 테스트 피라미드
1. **단위 테스트**: 각 함수/클래스 독립 테스트
2. **통합 테스트**: API 엔드포인트 테스트
3. **E2E 테스트**: 실제 브라우저에서 전체 플로우 테스트

### 테스트 도구
- **백엔드**: pytest
- **프론트엔드**: Jest, Playwright
- **API**: pytest-asyncio

## 📊 **성능 최적화**

### 프론트엔드
- **코드 스플리팅**: Next.js 자동 코드 스플리팅
- **이미지 최적화**: Next.js Image 컴포넌트
- **캐싱**: React Query 캐싱 전략

### 백엔드
- **비동기 처리**: FastAPI 비동기 엔드포인트
- **데이터베이스**: Connection Pooling
- **캐싱**: Redis 캐싱 (필요시)

## 🔍 **디버깅 및 모니터링**

### 개발 환경
- **콘솔 로그**: 상세한 로그 출력
- **React DevTools**: 컴포넌트 상태 추적
- **Network 탭**: API 호출 모니터링

### 배포 환경
- **Sentry**: 에러 추적 및 성능 모니터링
- **Cloud Logging**: 중앙화된 로그 관리
- **Health Check**: 서비스 상태 모니터링

## 📝 **코딩 컨벤션**

### TypeScript
- **엄격 모드**: strict: true
- **타입 안전성**: any 사용 최소화
- **인터페이스 우선**: 타입 정의 명확화

### React
- **함수형 컴포넌트**: Hooks 기반
- **Props 타입**: TypeScript 인터페이스 정의
- **이벤트 핸들러**: useCallback 최적화

### Python
- **타입 힌트**: 모든 함수에 타입 힌트
- **Pydantic**: 데이터 검증
- **SQLModel**: ORM 사용

## 🎯 **성공 지표**

### 기능 완성도
- ✅ 모든 CRUD 기능 정상 동작
- ✅ Undo/Redo 안정적 동작 (100% 신뢰성)
- ✅ 로컬/배포 환경 모두 지원
- ✅ 에러 발생 시 자동 복구

### 사용자 경험
- ✅ 직관적인 UI/UX
- ✅ 빠른 응답 속도
- ✅ 모바일 반응형 디자인
- ✅ 접근성 준수

### 기술적 품질
- ✅ 코드 품질 및 가독성
- ✅ 테스트 커버리지
- ✅ 보안 강화
- ✅ 확장 가능한 아키텍처